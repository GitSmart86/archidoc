use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use archidoc_types::{C4Level, ModuleDoc};

/// Return the Mermaid C4 container diagram as a markdown code block string.
pub fn container_diagram(docs: &[ModuleDoc]) -> String {
    let containers: Vec<&ModuleDoc> = docs
        .iter()
        .filter(|d| d.c4_level == C4Level::Container)
        .collect();

    let mut container_defs = String::new();
    for doc in &containers {
        let id = doc.module_path.replace('.', "_");
        let name = to_title_case(&doc.module_path);
        container_defs.push_str(&format!(
            "        Container({}, \"{}\", \"{}\", \"{}\")\n",
            id, name, doc.pattern, doc.description
        ));
    }

    let mut rel_defs = String::new();
    for doc in &containers {
        let from_id = doc.module_path.replace('.', "_");
        for rel in &doc.relationships {
            let to_id = rel.target.replace('.', "_");
            rel_defs.push_str(&format!(
                "    Rel({}, {}, \"{}\", \"{}\")\n",
                from_id, to_id, rel.label, rel.protocol
            ));
        }
    }

    format!(
        "```mermaid\nC4Container\n    title Container Diagram\n\n    System_Boundary(sys, \"System\") {{\n{}    }}\n\n{}\n    UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n```",
        container_defs,
        rel_defs,
    )
}

/// Generate Mermaid C4 container diagram file from `@c4 container` modules.
pub fn generate_container(output_dir: &Path, docs: &[ModuleDoc]) {
    let filepath = output_dir.join("c4-container.md");

    let containers: Vec<&ModuleDoc> = docs
        .iter()
        .filter(|d| d.c4_level == C4Level::Container)
        .collect();

    let table_rows: Vec<String> = containers
        .iter()
        .map(|d| format!("| {} | {} | {} |", d.module_path, d.pattern, d.description))
        .collect();

    let content = format!(
        "# C4 Container Diagram\n\n> Auto-generated by archidoc\n\n{}\n\n## Containers\n\n| Container | Pattern | Description |\n|-----------|---------|-------------|\n{}\n",
        container_diagram(docs),
        table_rows.join("\n")
    );

    fs::write(&filepath, content).expect("Failed to write c4-container.md");
}

/// Return the Mermaid C4 component diagram as a markdown code block string.
pub fn component_diagram(docs: &[ModuleDoc]) -> String {
    let components: Vec<&ModuleDoc> = docs
        .iter()
        .filter(|d| d.c4_level == C4Level::Component)
        .collect();

    let mut grouped: BTreeMap<String, Vec<&ModuleDoc>> = BTreeMap::new();
    for doc in &components {
        let parent = doc
            .parent_container
            .clone()
            .unwrap_or_else(|| "other".to_string());
        grouped.entry(parent).or_default().push(doc);
    }

    let mut boundary_defs = String::new();
    for (parent, component_docs) in &grouped {
        let parent_id = parent.replace('.', "_");
        let parent_name = to_title_case(parent);
        boundary_defs.push_str(&format!(
            "    Container_Boundary({}_boundary, \"{}\") {{\n",
            parent_id, parent_name
        ));
        for doc in component_docs {
            let id = doc.module_path.replace('.', "_");
            let name = doc
                .module_path
                .split('.')
                .last()
                .unwrap_or(&doc.module_path);
            boundary_defs.push_str(&format!(
                "        Component({}, \"{}\", \"{}\", \"{}\")\n",
                id, name, doc.pattern, doc.description
            ));
        }
        boundary_defs.push_str("    }\n\n");
    }

    let mut rel_defs = String::new();
    for doc in &components {
        let from_id = doc.module_path.replace('.', "_");
        for rel in &doc.relationships {
            let to_id = rel.target.replace('.', "_");
            rel_defs.push_str(&format!(
                "    Rel({}, {}, \"{}\", \"{}\")\n",
                from_id, to_id, rel.label, rel.protocol
            ));
        }
    }

    format!(
        "```mermaid\nC4Component\n    title Component Diagram (GoF Patterns)\n\n{}{}```",
        boundary_defs, rel_defs
    )
}

/// Generate Mermaid C4 component diagram file from `@c4 component` modules.
pub fn generate_component(output_dir: &Path, docs: &[ModuleDoc]) {
    let filepath = output_dir.join("c4-component.md");

    let content = format!(
        "# C4 Component Diagram\n\n> Auto-generated by archidoc\n\n{}\n",
        component_diagram(docs)
    );

    fs::write(&filepath, content).expect("Failed to write c4-component.md");
}

fn to_title_case(s: &str) -> String {
    s.split('.')
        .last()
        .unwrap_or(s)
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().to_string() + chars.as_str(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}
