use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use archidoc_types::{C4Level, ModuleDoc};

/// Generate Mermaid C4 container diagram from <<container>> modules.
///
/// Unlike the reference implementation, relationships come from
/// ModuleDoc.relationships â€” no hardcoded values.
pub fn generate_container(output_dir: &Path, docs: &[ModuleDoc]) {
    let filepath = output_dir.join("c4-container.md");

    let containers: Vec<&ModuleDoc> = docs
        .iter()
        .filter(|d| d.c4_level == C4Level::Container)
        .collect();

    let mut container_defs = String::new();
    for doc in &containers {
        let id = doc.module_path.replace('.', "_");
        let name = to_title_case(&doc.module_path);
        container_defs.push_str(&format!(
            "        Container({}, \"{}\", \"{}\", \"{}\")\n",
            id, name, doc.pattern, doc.description
        ));
    }

    // Collect all relationships from containers
    let mut rel_defs = String::new();
    for doc in &containers {
        let from_id = doc.module_path.replace('.', "_");
        for rel in &doc.relationships {
            let to_id = rel.target.replace('.', "_");
            rel_defs.push_str(&format!(
                "    Rel({}, {}, \"{}\", \"{}\")\n",
                from_id, to_id, rel.label, rel.protocol
            ));
        }
    }

    // Table
    let table_rows: Vec<String> = containers
        .iter()
        .map(|d| format!("| {} | {} | {} |", d.module_path, d.pattern, d.description))
        .collect();

    let content = format!(
        r#"# C4 Container Diagram

> Auto-generated by archidoc

```mermaid
C4Container
    title Container Diagram

    System_Boundary(sys, "System") {{
{}    }}

{}
    UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
```

## Containers

| Container | Pattern | Description |
|-----------|---------|-------------|
{}
"#,
        container_defs,
        rel_defs,
        table_rows.join("\n")
    );

    fs::write(&filepath, content).expect("Failed to write c4-container.md");
}

/// Generate Mermaid C4 component diagram from <<component>> modules.
pub fn generate_component(output_dir: &Path, docs: &[ModuleDoc]) {
    let filepath = output_dir.join("c4-component.md");

    let components: Vec<&ModuleDoc> = docs
        .iter()
        .filter(|d| d.c4_level == C4Level::Component)
        .collect();

    // Group components by parent container
    let mut grouped: BTreeMap<String, Vec<&ModuleDoc>> = BTreeMap::new();
    for doc in &components {
        let parent = doc
            .parent_container
            .clone()
            .unwrap_or_else(|| "other".to_string());
        grouped.entry(parent).or_default().push(doc);
    }

    let mut boundary_defs = String::new();
    for (parent, component_docs) in &grouped {
        let parent_id = parent.replace('.', "_");
        let parent_name = to_title_case(parent);
        boundary_defs.push_str(&format!(
            "    Container_Boundary({}_boundary, \"{}\") {{\n",
            parent_id, parent_name
        ));
        for doc in component_docs {
            let id = doc.module_path.replace('.', "_");
            let name = doc
                .module_path
                .split('.')
                .last()
                .unwrap_or(&doc.module_path);
            boundary_defs.push_str(&format!(
                "        Component({}, \"{}\", \"{}\", \"{}\")\n",
                id, name, doc.pattern, doc.description
            ));
        }
        boundary_defs.push_str("    }\n\n");
    }

    // Collect relationships from components
    let mut rel_defs = String::new();
    for doc in &components {
        let from_id = doc.module_path.replace('.', "_");
        for rel in &doc.relationships {
            let to_id = rel.target.replace('.', "_");
            rel_defs.push_str(&format!(
                "    Rel({}, {}, \"{}\", \"{}\")\n",
                from_id, to_id, rel.label, rel.protocol
            ));
        }
    }

    let content = format!(
        r#"# C4 Component Diagram

> Auto-generated by archidoc

```mermaid
C4Component
    title Component Diagram (GoF Patterns)

{}{}```
"#,
        boundary_defs, rel_defs
    );

    fs::write(&filepath, content).expect("Failed to write c4-component.md");
}

fn to_title_case(s: &str) -> String {
    s.split('.')
        .last()
        .unwrap_or(s)
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().to_string() + chars.as_str(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}
