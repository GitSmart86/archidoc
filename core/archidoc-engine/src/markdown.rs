use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use archidoc_types::ModuleDoc;

/// Generate per-module markdown files and the intro index.
pub fn generate_all(output_dir: &Path, docs: &[ModuleDoc]) {
    // Write individual module docs
    for doc in docs {
        if doc.module_path == "_lib" {
            continue;
        }
        write_module_doc(output_dir, doc);
    }

    // Write intro index
    generate_intro(output_dir, docs);
}

fn write_module_doc(output_dir: &Path, doc: &ModuleDoc) {
    let filename = format!("{}.md", doc.module_path);
    let filepath = output_dir.join(&filename);

    let content = format!(
        "# `{}`\n\n> Auto-generated from `{}`\n\n{}\n",
        doc.module_path, doc.source_file, doc.content
    );

    fs::write(&filepath, content)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", filepath.display(), e));
}

fn generate_intro(output_dir: &Path, docs: &[ModuleDoc]) {
    let filepath = output_dir.join("_intro.md");

    // Find lib.rs content for the main intro
    let lib_content = docs
        .iter()
        .find(|d| d.module_path == "_lib")
        .map(|d| d.content.as_str())
        .unwrap_or("# Architecture\n\n*No lib.rs documentation found.*");

    // Group by top-level module
    let mut grouped: BTreeMap<String, Vec<&ModuleDoc>> = BTreeMap::new();
    for doc in docs {
        if doc.module_path == "_lib" {
            continue;
        }
        let top_level = doc
            .module_path
            .split('.')
            .next()
            .unwrap_or(&doc.module_path);
        grouped.entry(top_level.to_string()).or_default().push(doc);
    }

    let mut index_entries = Vec::new();
    for (_, module_docs) in &grouped {
        for doc in module_docs {
            index_entries.push(format!(
                "| [{}](./{}.md) | {} | {} |",
                doc.module_path, doc.module_path, doc.pattern, doc.description
            ));
        }
    }

    let index_table = if index_entries.is_empty() {
        "*No module documentation found.*".to_string()
    } else {
        format!(
            "## Component Index\n\n\
             | Module | Pattern | Description |\n\
             |--------|---------|-------------|\n\
             {}\n",
            index_entries.join("\n")
        )
    };

    let content = format!(
        "{}\n\n---\n\n{}\n\n---\n\n*Auto-generated by archidoc. Do not edit manually.*\n",
        lib_content, index_table
    );

    fs::write(&filepath, content).expect("Failed to write _intro.md");
}
