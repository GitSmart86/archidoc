use std::path::Path;

use archidoc_types::{C4Level, ModuleDoc};

/// Generate the full ARCHITECTURE.md content as a string.
///
/// `root` is the project root directory, used to compute relative source
/// file links in the Component Index table.
///
/// Sections:
/// 1. Header + narrative (from _lib doc content)
/// 2. System Diagram (inline Mermaid C4 container)
/// 3. Component Diagram (inline Mermaid C4 component, if any)
/// 4. Component Index (table with source file links)
/// 5. Relationship Map
/// 6. Footer
pub fn generate(docs: &[ModuleDoc], root: &Path) -> String {
    let mut output = String::new();

    output.push_str("# Architecture Context\n\n");
    output.push_str("> Auto-generated by archidoc. Do not edit manually.\n\n");

    output.push_str(&section_narrative(docs));
    output.push_str(&section_container_diagram(docs));
    output.push_str(&section_component_diagram(docs));
    output.push_str(&section_component_index(docs, root));
    output.push_str(&section_relationship_map(docs));

    output.push_str("---\n\n*Auto-generated by archidoc. Do not edit manually.*\n");

    output
}

/// Extract narrative prose from the _lib module's content.
///
/// Filters out @c4 markers, file table rows, and GoF lines.
fn section_narrative(docs: &[ModuleDoc]) -> String {
    let lib_doc = docs.iter().find(|d| d.module_path == "_lib");
    let content = match lib_doc {
        Some(doc) => &doc.content,
        None => return String::new(),
    };

    let mut lines: Vec<&str> = Vec::new();
    let mut in_table = false;

    for line in content.lines() {
        let trimmed = line.trim();

        // Skip @c4 marker lines
        if trimmed.starts_with("@c4 ") {
            continue;
        }

        // Skip GoF lines
        if trimmed.starts_with("GoF:") {
            continue;
        }

        // Skip file table blocks
        if trimmed.starts_with("| File") || trimmed.starts_with("| file") {
            in_table = true;
            continue;
        }
        if in_table {
            if trimmed.starts_with('|') {
                continue;
            }
            in_table = false;
        }

        lines.push(line);
    }

    let narrative = lines.join("\n").trim().to_string();
    if narrative.is_empty() {
        String::new()
    } else {
        format!("{}\n\n", narrative)
    }
}

/// Inline Mermaid C4 container diagram.
fn section_container_diagram(docs: &[ModuleDoc]) -> String {
    let has_containers = docs.iter().any(|d| d.c4_level == C4Level::Container);
    if !has_containers {
        return String::new();
    }

    let diagram = crate::mermaid::container_diagram(docs);
    format!("## System Diagram\n\n{}\n\n", diagram)
}

/// Inline Mermaid C4 component diagram (skipped if no components).
fn section_component_diagram(docs: &[ModuleDoc]) -> String {
    let has_components = docs.iter().any(|d| d.c4_level == C4Level::Component);
    if !has_components {
        return String::new();
    }

    let diagram = crate::mermaid::component_diagram(docs);
    format!("## Component Diagram\n\n{}\n\n", diagram)
}

/// Component index table with links to source files.
///
/// Links are relative to `root` so they work when the generated markdown
/// is opened from any location within the project tree.
fn section_component_index(docs: &[ModuleDoc], root: &Path) -> String {
    let mut modules: Vec<&ModuleDoc> = docs
        .iter()
        .filter(|d| d.module_path != "_lib")
        .collect();
    modules.sort_by(|a, b| a.module_path.cmp(&b.module_path));

    if modules.is_empty() {
        return String::new();
    }

    let mut output = String::new();
    output.push_str("## Component Index\n\n");
    output.push_str("| Module | Level | Pattern | Description |\n");
    output.push_str("|--------|-------|---------|-------------|\n");

    for doc in &modules {
        let source = Path::new(&doc.source_file);
        let rel = pathdiff::diff_paths(source, root)
            .unwrap_or_else(|| source.to_path_buf());
        output.push_str(&format!(
            "| [{}]({}) | {} | {} | {} |\n",
            doc.module_path,
            rel.display().to_string().replace('\\', "/"),
            doc.c4_level,
            doc.pattern,
            doc.description,
        ));
    }

    output.push('\n');
    output
}

/// Flat relationship map across all modules.
fn section_relationship_map(docs: &[ModuleDoc]) -> String {
    let all_rels: Vec<(&str, &archidoc_types::Relationship)> = docs
        .iter()
        .flat_map(|doc| {
            doc.relationships
                .iter()
                .map(move |r| (doc.module_path.as_str(), r))
        })
        .collect();

    if all_rels.is_empty() {
        return String::new();
    }

    let mut output = String::new();
    output.push_str("## Relationship Map\n\n");

    for (source, rel) in &all_rels {
        output.push_str(&format!(
            "- {} -> {}: \"{}\" ({})\n",
            source, rel.target, rel.label, rel.protocol
        ));
    }

    output.push('\n');
    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use archidoc_types::{C4Level, PatternStatus, Relationship};

    fn test_root() -> &'static Path {
        Path::new("")
    }

    fn make_container(name: &str, desc: &str) -> ModuleDoc {
        ModuleDoc {
            module_path: name.to_string(),
            content: String::new(),
            source_file: format!("src/{}/mod.rs", name),
            c4_level: C4Level::Container,
            pattern: "--".to_string(),
            pattern_status: PatternStatus::Planned,
            description: desc.to_string(),
            parent_container: None,
            relationships: vec![],
            files: vec![],
        }
    }

    fn make_component(parent: &str, name: &str, desc: &str) -> ModuleDoc {
        let full_path = format!("{}.{}", parent, name);
        ModuleDoc {
            module_path: full_path.clone(),
            content: String::new(),
            source_file: format!("src/{}/{}/mod.rs", parent, name),
            c4_level: C4Level::Component,
            pattern: "--".to_string(),
            pattern_status: PatternStatus::Planned,
            description: desc.to_string(),
            parent_container: Some(parent.to_string()),
            relationships: vec![],
            files: vec![],
        }
    }

    fn make_lib(content: &str) -> ModuleDoc {
        ModuleDoc {
            module_path: "_lib".to_string(),
            content: content.to_string(),
            source_file: "src/lib.rs".to_string(),
            c4_level: C4Level::Container,
            pattern: "--".to_string(),
            pattern_status: PatternStatus::Planned,
            description: "Root module".to_string(),
            parent_container: None,
            relationships: vec![],
            files: vec![],
        }
    }

    #[test]
    fn empty_docs_produces_header_and_footer() {
        let output = generate(&[], test_root());
        assert!(output.contains("# Architecture Context"));
        assert!(output.contains("Auto-generated by archidoc"));
        assert!(!output.contains("## System Diagram"));
        assert!(!output.contains("## Component Index"));
    }

    #[test]
    fn single_container_produces_diagram_and_index() {
        let docs = vec![make_container("api", "REST API gateway")];
        let output = generate(&docs, test_root());

        assert!(output.contains("## System Diagram"));
        assert!(output.contains("```mermaid"));
        assert!(output.contains("Container(api"));
        assert!(output.contains("## Component Index"));
        assert!(output.contains("| [api](src/api/mod.rs) | container | -- | REST API gateway |"));
    }

    #[test]
    fn components_produce_component_diagram() {
        let docs = vec![
            make_container("bus", "Central messaging"),
            make_component("bus", "calc", "Indicator calculations"),
        ];
        let output = generate(&docs, test_root());

        assert!(output.contains("## Component Diagram"));
        assert!(output.contains("C4Component"));
        assert!(output.contains("Component(bus_calc"));
    }

    #[test]
    fn no_component_diagram_when_no_components() {
        let docs = vec![make_container("api", "REST API")];
        let output = generate(&docs, test_root());

        assert!(!output.contains("## Component Diagram"));
    }

    #[test]
    fn relationships_appear_in_map() {
        let mut api = make_container("api", "REST API gateway");
        api.relationships = vec![Relationship {
            target: "database".to_string(),
            label: "Persists data".to_string(),
            protocol: "sqlx".to_string(),
        }];

        let docs = vec![api, make_container("database", "Data store")];
        let output = generate(&docs, test_root());

        assert!(output.contains("## Relationship Map"));
        assert!(output.contains("- api -> database: \"Persists data\" (sqlx)"));
    }

    #[test]
    fn narrative_extracted_from_lib() {
        let lib = make_lib("@c4 container\n\n# My Project\n\nA cool project.\n\n## Data Flow\n\n1. Step one\n2. Step two");
        let docs = vec![lib, make_container("api", "REST API")];
        let output = generate(&docs, test_root());

        assert!(output.contains("# My Project"));
        assert!(output.contains("A cool project."));
        assert!(output.contains("## Data Flow"));
        assert!(output.contains("1. Step one"));
        assert!(!output.contains("@c4 container"));
    }

    #[test]
    fn narrative_filters_file_tables() {
        let lib = make_lib("@c4 container\n\n# Engine\n\nCore system.\n\n| File | Pattern | Purpose | Health |\n|------|---------|---------|--------|\n| `core.rs` | Facade | Entry point | stable |\n\nGoF: Mediator");
        let docs = vec![lib];
        let output = generate(&docs, test_root());

        assert!(output.contains("Core system."));
        assert!(!output.contains("| File |"));
        assert!(!output.contains("core.rs"));
        assert!(!output.contains("GoF:"));
    }

    #[test]
    fn index_links_use_forward_slashes() {
        let mut doc = make_container("api", "REST API");
        doc.source_file = "src\\api\\mod.rs".to_string();
        let output = generate(&[doc], test_root());

        assert!(output.contains("[api](src/api/mod.rs)"));
    }

    #[test]
    fn lib_module_excluded_from_index() {
        let lib = make_lib("# Root\n\nNarrative.");
        let api = make_container("api", "REST API");
        let output = generate(&[lib, api], test_root());

        // _lib should NOT appear in component index
        assert!(!output.contains("| [_lib]"));
        // api should appear
        assert!(output.contains("| [api]"));
    }
}
